<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>软工二知识点整理 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="软工二知识点整理">
<meta property="og:type" content="article">
<meta property="og:title" content="软工二知识点整理">
<meta property="og:url" content="http://example.com/2020/09/03/%E8%BD%AF%E5%B7%A5%E4%BA%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="软工二知识点整理">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-09-03T06:11:36.744Z">
<meta property="article:modified_time" content="2020-09-03T06:15:41.467Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="软工二">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-软工二知识点整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/03/%E8%BD%AF%E5%B7%A5%E4%BA%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2020-09-03T06:11:36.744Z" itemprop="datePublished">2020-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      软工二知识点整理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="软工二知识点整理"><a href="#软工二知识点整理" class="headerlink" title="软工二知识点整理"></a>软工二知识点整理</h1><a id="more"></a>

<h2 id="第1章-软件工程基础"><a href="#第1章-软件工程基础" class="headerlink" title="第1章 软件工程基础"></a>第1章 软件工程基础</h2><h3 id="名词解释：软件工程的定义"><a href="#名词解释：软件工程的定义" class="headerlink" title="*名词解释：软件工程的定义"></a>*名词解释：软件工程的定义</h3><p>（1）应用系统的、规范的、可量化的方法，来开发、运行和维护软件，即将工程应用到软件</p>
<p>（2）对（1）中各种方法的研究</p>
<h2 id="第2章-软件工程的发展"><a href="#第2章-软件工程的发展" class="headerlink" title="第2章 软件工程的发展"></a>第2章 软件工程的发展</h2><h3 id="1950s-2000s软件工程的特点"><a href="#1950s-2000s软件工程的特点" class="headerlink" title="*1950s-2000s软件工程的特点"></a>*1950s-2000s软件工程的特点</h3><p>1950s：科学计算：以机器为中心进行编程；像硬件一样去生产软件</p>
<p>1960s：业务应用（批量数据处理和事务计算）；硬件不同于软件；用软件工艺的方法生产软件</p>
<p>1970s：结构化方法；瀑布模型；强调规则和纪律</p>
<p>1980s：追求生产力最大化；现代结构化方法/面向对象编程广泛应用；重视过程的作用</p>
<p>1990s：企业为中心的大规模软件开发；追求快速开发、可变更新和用户价值；web应用出现</p>
<p>2000s：大规模web应用；大量面向大众的web产品；追求快速开发、可变更性、用户价值和创新</p>
<h2 id="第4章-项目启动"><a href="#第4章-项目启动" class="headerlink" title="第4章 项目启动"></a>第4章 项目启动</h2><p>项目管理的目的：项目管理是将知识、技能、工具与技术应用于项目活动，以满足项目的要求</p>
<h3 id="团队结构-3"><a href="#团队结构-3" class="headerlink" title="*团队结构 3"></a>*团队结构 3</h3><p>（1）主程序员团队</p>
<p>特点：主程序员负责领导团队，效率较高，能最大限度地保证产品不同元素的一致性</p>
<p>局限：主程序员的能力是瓶颈；团队成员无法发挥主动性，积极程度不高</p>
<p>（2）民主团队</p>
<p>特点：每个成员都可以发挥自己的能动性，所有人都可以在自己擅长的领域工作</p>
<p>局限：花费在交流，统一思想上的时间成本太大，效率较低</p>
<p>（3）开放团队</p>
<p>特点：使用黑箱管理方式，团队内部的交流路径不可见的。所有成员按照自己的方式进行自我管理，最大发挥团队成员的创新能力</p>
<p>局限：项目进展没有可视度</p>
<h3 id="团队建设措施"><a href="#团队建设措施" class="headerlink" title="团队建设措施"></a>团队建设措施</h3><ul>
<li>建立团队章程</li>
<li>持续成功（项目的整体成功，项目的阶段性成功，无关的团队活动的成功）</li>
<li>和谐沟通</li>
<li>避免团队杀手</li>
</ul>
<h3 id="质量保障活动-4（结合实验）"><a href="#质量保障活动-4（结合实验）" class="headerlink" title="*质量保障活动 4（结合实验）"></a>*质量保障活动 4（结合实验）</h3><p>质量验证的方法主要有评审、测试和质量度量三种</p>
<ul>
<li>需求开发：需求评审、需求度量</li>
<li>体系结构：体系结构评审、集成测试</li>
<li>详细设计：详细设计评审、设计度量、集成测试</li>
<li>实现：代码评审、代码度量、测试度量、测试</li>
</ul>
<p><strong>题目</strong>：结合实验说明一个项目的质量保障包括哪些活动</p>
<h3 id="配置管理活动-6（结合实验）"><a href="#配置管理活动-6（结合实验）" class="headerlink" title="*配置管理活动 6（结合实验）"></a>*配置管理活动 6（结合实验）</h3><ul>
<li>标识配置项：首先确定哪些配置项需要被保存和管理，其次要给配置项确定标识，设置唯一的ID，最后要说明配置项的特征，包括生产者、基线建立时间、使用者等</li>
<li>版本管理：为配置项赋予版本号，并在发生变更时更新版本号</li>
<li>变更控制：根据变更控制过程，以可控、一致的方式进行变更处理<ul>
<li>提交变更、接受变更请求、变更评估、变更决策、执行变更、验证变更</li>
</ul>
</li>
<li>配置审计：确定一个项目满足需求的功能和物理特征的程度</li>
<li>状态报告：标识、收集和维持演化中的配置状态信息</li>
<li>软件发布管理：将软件配置项发布到开发活动之外</li>
</ul>
<h2 id="第5章-软件需求基础"><a href="#第5章-软件需求基础" class="headerlink" title="第5章 软件需求基础"></a>第5章 软件需求基础</h2><h3 id="名词解释：需求的定义"><a href="#名词解释：需求的定义" class="headerlink" title="*名词解释：需求的定义"></a>*名词解释：需求的定义</h3><p>（1）用户为了解决问题或达到某些目标所需要的条件或能力</p>
<p>（2）系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力</p>
<p>（3）对（1）或（2）中的一个条件或一种能力的一种文档化表述</p>
<h3 id="需求的层次性"><a href="#需求的层次性" class="headerlink" title="*需求的层次性"></a>*需求的层次性</h3><ul>
<li>业务需求：描述了组织为什么要开发系统（目标）</li>
<li>用户需求：描述了系统可以帮助用户做些什么（任务）</li>
<li>系统级需求：描述了开发人员需要实现什么（系统行为）<ul>
<li>软件需求、硬件需求、其他需求</li>
</ul>
</li>
</ul>
<h3 id="需求分类"><a href="#需求分类" class="headerlink" title="*需求分类"></a>*需求分类</h3><ul>
<li>功能需求：和系统主要工作相关的需求，即不考虑物理约束的情况下，用户希望系统所能执行的活动</li>
<li>性能需求：定义了系统必须多快、多好地去完成专门的功能。速度、容量、吞吐量、负载、实时性</li>
<li>质量属性：可靠性、可用性、安全性、可维护性、可移植性、易用性</li>
<li>对外接口：系统和环境中其他系统之间需要建立的接口（用户界面、硬件接口、软件接口、网络通信接口）</li>
<li>约束：进行系统构造时需要遵守的约定（编程语言、硬件设施）</li>
<li>数据需求：不是标准的需求类别，时功能需求的补充，通常就是描述数据库等存储介质</li>
</ul>
<h2 id="第6章-需求分析方法"><a href="#第6章-需求分析方法" class="headerlink" title="第6章 需求分析方法"></a>第6章 需求分析方法</h2><p>如何绘制 <strong>用例图</strong>、<strong>概念类图</strong>、<strong>顺序图</strong>、<strong>状态图</strong></p>
<h3 id="建立用例图"><a href="#建立用例图" class="headerlink" title="建立用例图"></a>建立用例图</h3><ol>
<li>进行目标分析与确定解决方向</li>
<li>寻找参与者</li>
<li>寻找用例</li>
<li>细化用例</li>
</ol>
<p>注意事项：不要将用例细化为单个操作，不要将同一业务目标细化为不同用例，不要将没有业务价值的内容作为用例</p>
<h3 id="建立概念类图"><a href="#建立概念类图" class="headerlink" title="建立概念类图"></a>建立概念类图</h3><p>概念类图又称为领域模型，关注系统与外界的交互</p>
<ol>
<li>识别候选类</li>
<li>确定概念类</li>
<li>识别关联</li>
<li>识别重要属性</li>
</ol>
<h3 id="建立系统顺序图"><a href="#建立系统顺序图" class="headerlink" title="建立系统顺序图"></a>建立系统顺序图</h3><ol>
<li>确定上下文环境</li>
<li>发现交互对象</li>
<li>根据用例描述中的流程，逐步添加信息</li>
</ol>
<h3 id="建立状态图"><a href="#建立状态图" class="headerlink" title="建立状态图"></a>建立状态图</h3><ol>
<li>确定上下文环境，搞清楚状态的主题</li>
<li>识别状态</li>
<li>建立状态转换</li>
<li>补充详细信息</li>
</ol>
<h2 id="第7章-需求文档化与验证"><a href="#第7章-需求文档化与验证" class="headerlink" title="第7章 需求文档化与验证"></a>第7章 需求文档化与验证</h2><h3 id="为什么要进行需求规格说明"><a href="#为什么要进行需求规格说明" class="headerlink" title="为什么要进行需求规格说明"></a>为什么要进行需求规格说明</h3><p>需求规格说明文档是项目交流的最重要内容，众多开发人员都需要以其为基础进行工作，如果软件需求规格说明文档存在错误，那么会给后续开发工作带来很多问题，再修复的代价就很高</p>
<h3 id="对给定的需求示例，判定并修正其错误"><a href="#对给定的需求示例，判定并修正其错误" class="headerlink" title="*对给定的需求示例，判定并修正其错误"></a>*对给定的需求示例，判定并修正其错误</h3><ul>
<li>使用用户术语<ul>
<li>对用户易读，不要使用计算机术语</li>
</ul>
</li>
<li>可验性<ul>
<li>描述模糊或过于抽象的需求都是不可验证的（如：用户查询的界面应该友好，该表述是不可验证的；用户完成查询时鼠标点击不超过五次，该表述是可验证的）</li>
</ul>
</li>
<li>可行性<ul>
<li>系统必须每周7天，每天24小时可用（不可行）</li>
</ul>
</li>
</ul>
<h3 id="对给定的需求示例，设计功能测试用例"><a href="#对给定的需求示例，设计功能测试用例" class="headerlink" title="*对给定的需求示例，设计功能测试用例"></a>*对给定的需求示例，设计功能测试用例</h3><p>书本P125</p>
<p>写输入，写出预期输出，中间给出说明</p>
<h2 id="第8章-软件设计基础"><a href="#第8章-软件设计基础" class="headerlink" title="第8章 软件设计基础"></a>第8章 软件设计基础</h2><h3 id="名词解释：软件设计"><a href="#名词解释：软件设计" class="headerlink" title="*名词解释：软件设计"></a>*名词解释：软件设计</h3><p>软件设计是关于整个软件对象的设计，软件设计既指软件对象实现的规格说明，也指产生这个规格说明的过程</p>
<h3 id="软件设计的核心思想"><a href="#软件设计的核心思想" class="headerlink" title="软件设计的核心思想"></a>软件设计的核心思想</h3><p>抽象和分解</p>
<p>抽象是纵向上聚焦各自系统的接口，这里的接口和实现是相对的，是各自系统之间交流的契约，是整个系统的关键所在、本质所在，抽象可以分离接口和实现，让人更好地关注系统本身，从而降低复杂度</p>
<p>分解是在横向上将系统分割为几个相对简单的自系统以及各自系统直接的关系，分解之后每次只需要关注经过抽象的相对简单的子系统及其项目间的关系，从而降低了复杂度</p>
<h3 id="软件设计的分层"><a href="#软件设计的分层" class="headerlink" title="软件设计的分层"></a>软件设计的分层</h3><p>高层：基于反映软件高层抽象的构建层级，描述系统的高层结构、关注点和设计决策</p>
<p>中层：更加关注组成构建的模块的划分、导入/导出、过程之间的调用关系或者类之间的协作</p>
<p>低级：深入模块和类的内部，关注具体的数据结构、算法、类型、语句和控制结构等</p>
<h2 id="第9章-软件体系结构基础"><a href="#第9章-软件体系结构基础" class="headerlink" title="第9章 软件体系结构基础"></a>第9章 软件体系结构基础</h2><h3 id="体系结构含义"><a href="#体系结构含义" class="headerlink" title="体系结构含义"></a>体系结构含义</h3><p>软件体系结构 = { 部件 、 连接件 、 配置 }</p>
<p>部件：软件体系结构的基本组成单位之一，承载系统的主要功能，包括处理与数据</p>
<p>连接件：软件体系结构的另一个基本组成单位，定义了部件之间的交互，是链接的抽象表示</p>
<p>配置：对“形式”的发展，定义了“部件”以及“连接件”之间的关联方式，将他们组织成系统的总体结构。</p>
<h3 id="体系风格的优缺点"><a href="#体系风格的优缺点" class="headerlink" title="*体系风格的优缺点"></a>*体系风格的优缺点</h3><ul>
<li><p>主程序/子程序：主程序是系统的控制器，负责调度各子程序的执行。各子程序又是一个局部的控制器，负责调度其子子程序的执行。</p>
<ul>
<li>优点：<ul>
<li>流程清晰，易于理解（符合分解和分治的思想）</li>
<li>强控制性（很容易保证正确性）</li>
</ul>
</li>
<li>缺点：<ul>
<li>程序调用是一种强耦合的连接方式，非常依赖交互方的接口规范，这会使得系统难以修改和复用</li>
<li>程序调用的连接方式限制了各部件之间的数据交互，可能会使得不同部件使用隐含的共享数据交流，产生不必要的公共耦合，进而破坏它的“正确性”控制能力</li>
</ul>
</li>
</ul>
</li>
<li><p>面向对象式：将系统组织为多个独立的对象，每个对象封装其内部的数据，并对基于数据对外提供服务。不同对象之间通过协作机制来共同完成系统任务</p>
<ul>
<li>优点：<ul>
<li>内部实现的可修改性（隐藏内部实现）</li>
<li>易开发、易理解、易复用的结构组织（契合模块化思想）</li>
</ul>
</li>
<li>缺点：<ul>
<li>接口的耦合性（由于方法调用机制，接口的耦合性无法消除）</li>
<li>标识的耦合性（一个对象要和其他对象交互，必须知道标识）</li>
<li>副作用（难以实现程序的“正确性”）</li>
</ul>
</li>
</ul>
</li>
<li><p>分层：根据不同的抽象层次，将系统组织为层次式结构。每个层次被建立为一个部位，不同部件之间通常用程序调用方式进行连接，因此连接件被建立为程序调用机制</p>
<ul>
<li><p>优点：设计机制清晰，易于理解（抽象层次分离，隔离复杂度）</p>
<ul>
<li><p>支持并行开发（层次之间遵守成熟稳定的接口）</p>
</li>
<li><p>更好的可复用性与内部可修改性（接口的稳定性，不同层次的部件能够互相替换）</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>交互协议难以修改（可能需要改变所有的层次，接口具有强耦合性）</p>
</li>
<li><p>性能损失（禁止跨层调用）</p>
</li>
<li><p>难以确定层次数量和粒度</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>MVC：模型-视图-控制</p>
<ul>
<li>优点：<ul>
<li>易开发性（分别抽象了业务逻辑，表现和控制机制清晰，易于开发）</li>
<li>视图和控制的可控制性（一个模型可以同时建立并支持多个视图）</li>
<li>适宜于网络系统开发的特征</li>
</ul>
</li>
<li>缺点：<ul>
<li>复杂性（不利于理解任务实现）</li>
<li>模型修改困难（视图和控制均依赖于模型）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第10章-软件体系结构设计与构建"><a href="#第10章-软件体系结构设计与构建" class="headerlink" title="第10章 软件体系结构设计与构建"></a>第10章 软件体系结构设计与构建</h2><h3 id="体系结构的设计过程"><a href="#体系结构的设计过程" class="headerlink" title="体系结构的设计过程"></a>体系结构的设计过程</h3><ol>
<li>分析关键需求和项目约束</li>
<li>选择体系结构风格</li>
<li>进行软件体系结构逻辑（抽象）设计</li>
<li>依赖逻辑设计进行软件体系结构物理（实现）设计</li>
<li>完善软件体系结构设计</li>
<li>定义构建接口</li>
<li>迭代过程（3）到（6）</li>
</ol>
<h3 id="包设计原则"><a href="#包设计原则" class="headerlink" title="包设计原则"></a>包设计原则</h3><ul>
<li>共同封闭原则（CCP）：一起改的类应该在一起</li>
<li>共同重用原则（CRP）：一起重用的包应该放在一起</li>
<li>重用发布等价原则（REP）：重用的单元就是发布的单元</li>
<li>无环依赖原则（ADP）：包的依赖结构是一个有向无环</li>
<li>稳定依赖原则（SDP）：依赖关系应该随着稳定的方向</li>
<li>稳定抽象原则（SAP）：稳定包应该是抽象包，不稳定包是具体包</li>
</ul>
<h3 id="体系结构构建之间接口的定义"><a href="#体系结构构建之间接口的定义" class="headerlink" title="*体系结构构建之间接口的定义"></a>*体系结构构建之间接口的定义</h3><p>书本P174</p>
<p>能够根据用例写出某层的接口，需求分配的过程</p>
<h3 id="体系结构开发集成测试用例"><a href="#体系结构开发集成测试用例" class="headerlink" title="体系结构开发集成测试用例"></a>体系结构开发集成测试用例</h3><p>书本P177</p>
<p>桩（Stub）：在软件测试里用来替换某些模块的，模仿下层模块，测试上层</p>
<p>驱动（Driver）：模仿上层模块，测试下层</p>
<h2 id="第11章-人机交互设计"><a href="#第11章-人机交互设计" class="headerlink" title="第11章 人机交互设计"></a>第11章 人机交互设计</h2><h3 id="名词解释：可用性"><a href="#名词解释：可用性" class="headerlink" title="*名词解释：可用性"></a>*名词解释：可用性</h3><p>书上为易用性（Usability）</p>
<p>五个维度：</p>
<ul>
<li>易学性：新手用户容易学习，能够很快使用系统</li>
<li>易记性：以前使用过该软件的用户，能够有效记忆或者快速重新学会使用</li>
<li>效率：熟练用户能够高效地完成任务</li>
<li>出错率：用户使用系统时，会犯多少错、错误有多严重，以及能够从错误中很容易恢复</li>
<li>主观满意度：让用户有良好的体验</li>
</ul>
<h3 id="人机交互设计原则"><a href="#人机交互设计原则" class="headerlink" title="人机交互设计原则"></a>人机交互设计原则</h3><ul>
<li>简洁设计：图片比描述文字更清晰</li>
<li>一致性设计：相似的任务，一致的交互机制</li>
<li>低出错率：帮助用户避免犯错</li>
<li>易记忆性：历史记录</li>
<li>可视化设计</li>
</ul>
<p><strong>题目</strong>：根据图例，分析体现（违法）了哪些人机交互原则、详细解释</p>
<h3 id="精神模型、差异性"><a href="#精神模型、差异性" class="headerlink" title="精神模型、差异性"></a>精神模型、差异性</h3><p>书本P185-186</p>
<p>精神模型：用户在进行人机交互时头脑中的人物模型</p>
<p>差异性：不同的用户群体、差异化的交互机制</p>
<h3 id="导航、反馈、协作式设计"><a href="#导航、反馈、协作式设计" class="headerlink" title="*导航、反馈、协作式设计"></a>*导航、反馈、协作式设计</h3><p>导航：目的是为用户提供一个很好的完成任务的入口</p>
<p>反馈：让用户意识到行为的结果（声音、视觉效果）</p>
<p>协作式设计：调整计算机因素以便更好地适应并帮助用户设计</p>
<h2 id="第12章-详细设计的基础"><a href="#第12章-详细设计的基础" class="headerlink" title="第12章 详细设计的基础"></a>第12章 详细设计的基础</h2><h3 id="详细设计的出发点"><a href="#详细设计的出发点" class="headerlink" title="详细设计的出发点"></a>详细设计的出发点</h3><p>以需求开发的结果（需求规格说明和需求分析模型）和软件体现结构的结果（软件体系结构设计方案与模型）为出发点</p>
<p>书本P197，建造桥梁</p>
<h3 id="职责分配"><a href="#职责分配" class="headerlink" title="*职责分配"></a>*职责分配</h3><ol>
<li>职责是持有某项数据或者表现某种职责的义务；数据职责主要由属性满足，行为职责主要由方法满足；可能会包含类间协作</li>
<li>职责可以从不同的抽象层次开始；职责是可以被分解的；指责分解可以是分解组件的基础</li>
<li>职责分配可以帮助实现高内聚低耦合，确保不同模块职责没有重合，当且仅当数据和方法有助于实现模块职责时将其添加给模块</li>
<li>GRASP原则（通用职责分配软件模式–将职责分配原则总结为模式）<ul>
<li>信息专家<ul>
<li>基本的职责分配原则之一，把职责分配给具有完成该职责所需信息的那个类</li>
<li>优点：促进低耦合、高内聚，维护信息封装</li>
</ul>
</li>
<li>创建者模式<ul>
<li>根据潜在创建者类和要被实例化的类之间的关系决定哪个类创建实例</li>
<li>当满足以下条件时，B创建A：B包含A，或B组合A；B直接使用A；B拥有A的初始化记录；B记录A</li>
</ul>
</li>
<li>控制器模式：<ul>
<li>处理外部事件（用户和系统时钟发生的外部交互）</li>
<li>核心思想：解耦</li>
<li>不要界面直接调用代码，也不要代码直接调用界面，把系统/人/用例作为控制器</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="协作"><a href="#协作" class="headerlink" title="*协作"></a>*协作</h3><p>抽象对象之间的协作</p>
<ul>
<li>从小到大，将对象的小职责聚合成大职责</li>
<li>从大到小，将大职责分配给小对象</li>
<li>上面两种方法一般都是同时运用，共同完成对协作的抽象</li>
</ul>
<h3 id="控制风格"><a href="#控制风格" class="headerlink" title="*控制风格"></a>*控制风格</h3><p>选择合适的控制风格：</p>
<ul>
<li><p>为了完成某一个大的职责，需要对分配做很多决策。控制风格决定了决策由谁来做和怎么做决策</p>
</li>
<li><p>逻辑层的接口依据需求来创建</p>
</li>
<li><p>集中式：做决策的往往只有一个对象，由这个对象决定怎么来分配职责，怎么来实现大的职责</p>
</li>
<li><p>委派式：做出决策的对象不只一个，这些对象分别承担一定的职责，做出一定的决策，从而共同实现大的职责</p>
</li>
<li><p>分散式：无法找到明确的控制对象，每个对象都只承担一个相对较小的职责，完全靠各个对象自治的方式来实现大的职责</p>
</li>
</ul>
<h3 id="建立设计类图"><a href="#建立设计类图" class="headerlink" title="*建立设计类图"></a>*建立设计类图</h3><p>书本P203，表12-2</p>
<h3 id="建立详细顺序图"><a href="#建立详细顺序图" class="headerlink" title="*建立详细顺序图"></a>*建立详细顺序图</h3><p>书本P206，表12-3</p>
<p><strong>题目</strong>：给出用例描述，用集中控制的方式画出设计类图和顺序图</p>
<h3 id="协作的测试"><a href="#协作的测试" class="headerlink" title="协作的测试"></a>协作的测试</h3><p>Mock Project：雷剑协作的桩程序</p>
<p>书本P210-212</p>
<h2 id="第13章-详细设计中的模块化与信息隐藏"><a href="#第13章-详细设计中的模块化与信息隐藏" class="headerlink" title="第13章 详细设计中的模块化与信息隐藏"></a>第13章 详细设计中的模块化与信息隐藏</h2><h3 id="名词解释：耦合和内聚"><a href="#名词解释：耦合和内聚" class="headerlink" title="*名词解释：耦合和内聚"></a>*名词解释：耦合和内聚</h3><p>耦合：描述两个模块间关系的复杂程度</p>
<p>内聚：描述一个模块内部的联系的紧密性</p>
<h3 id="结构化设计中的耦合"><a href="#结构化设计中的耦合" class="headerlink" title="*结构化设计中的耦合"></a>*结构化设计中的耦合</h3><p>分类（耦合性从高到低）<strong>6</strong>：</p>
<ul>
<li>内容耦合：一个模块直接修改或者依赖于另一个模块的内容（GOTO）</li>
<li>公共耦合：模块之间共享全局的数据（全局变量）</li>
<li>重复耦合：模块之间有相同逻辑的代码</li>
<li>控制耦合：一个模块给另一个模块传递控制信息</li>
<li>印记耦合：共享了一个数据结构，但是却只用了其中一部分（传了整个记录，只需要一个字段）</li>
<li>数据耦合：两个模块的所有参数是同类型的数据项（传一个整数给计算平方根的函数）</li>
</ul>
<h3 id="结构化设计中的内聚"><a href="#结构化设计中的内聚" class="headerlink" title="*结构化设计中的内聚"></a>*结构化设计中的内聚</h3><p>分类（内聚性从低到高）<strong>7</strong>：</p>
<ul>
<li>偶然内聚：模块执行多个完全不相关的操作<ul>
<li>修车、烤面包、遛狗、看电影</li>
</ul>
</li>
<li>逻辑内聚：模块执行一系列相关操作，每个操作的调用由其他模块决定<ul>
<li>开车去上班、坐火车去上班、坐飞机去上班</li>
</ul>
</li>
<li>时间内聚：模块执行一系列有关时间的操作<ul>
<li>起床、刷牙、洗脸、吃早饭</li>
</ul>
</li>
<li>过程内聚：模块执行一系列与步骤顺序有关的操作<ul>
<li>返校：院系经办人审核、院系领导审核、校职能部审核</li>
</ul>
</li>
<li>通信内聚：模块执行一系列与步骤顺序有关的操作，并且这些操作中相同的数据上进行<ul>
<li>查书名、查书作者、查书出版社</li>
</ul>
</li>
<li>功能内聚：模块只执行一个操作或达到单一目的<ul>
<li>计算平方根、决定最短路径</li>
</ul>
</li>
<li>信息内聚：模块进行许多操作，各有各的入口点，每个操作的代码相对独立，所有操作都是在相同的数据结构上完成<ul>
<li>栈，包含相应的数据和操作，所有的操作都是针对相同的数据结构</li>
</ul>
</li>
</ul>
<h3 id="信息隐藏的基本思想"><a href="#信息隐藏的基本思想" class="headerlink" title="*信息隐藏的基本思想"></a>*信息隐藏的基本思想</h3><p>每个模块都隐藏着一个重要的设计决策，每个模块都承担一定的职责，对外表现为一份契约，并且在这份契约之下隐藏着只有这个模块知道的设计决策或者秘密，决策实现的细节（特别是容易改变的细节）只有模块自己知道</p>
<h3 id="两种常见的信息隐藏决策"><a href="#两种常见的信息隐藏决策" class="headerlink" title="两种常见的信息隐藏决策"></a>两种常见的信息隐藏决策</h3><ul>
<li>根据需求分配的职责</li>
<li>内部实现机制</li>
</ul>
<h3 id="面向对象设计原则（重要）12点"><a href="#面向对象设计原则（重要）12点" class="headerlink" title="*面向对象设计原则（重要）12点"></a>*面向对象设计原则（重要）12点</h3><ol>
<li>全局变量有害</li>
<li>显式（explicit），显示得清楚一点</li>
<li>不要重复</li>
<li>按照接口编程</li>
<li>最小化类和成员的可访达性</li>
<li>使用组合替代集成</li>
<li>迪米特法则（Law Of Demeter）</li>
<li>接口分离原则（ISP–Interface Segregation Principle）</li>
<li>里氏替换原则（Liskov Substitution Principle）</li>
<li>单一职责原则（SRP–Single Responsibility Principle）</li>
<li>开放关闭原则（OCP–Open Close Principle）</li>
<li>依赖倒置原则（DIP–Dependence Inversion Principle）</li>
</ol>
<h2 id="第14章-详细设计中面向对象方法下的模块化"><a href="#第14章-详细设计中面向对象方法下的模块化" class="headerlink" title="第14章 详细设计中面向对象方法下的模块化"></a>第14章 详细设计中面向对象方法下的模块化</h2><h3 id="模块化设计原则"><a href="#模块化设计原则" class="headerlink" title="*模块化设计原则"></a>*模块化设计原则</h3><ol>
<li>全局变量有害<ul>
<li>不要用全局变量</li>
</ul>
</li>
<li>显式（explicit），显示得清楚一点<ul>
<li>内容明确</li>
</ul>
</li>
<li>不要有代码重复</li>
<li>按照接口编程</li>
<li>迪米特法则（Law Of Demeter）</li>
<li>接口分离原则（ISP–Interface Segregation Principle）</li>
<li>里氏替换原则（Liskov Substitution Principle）</li>
<li>使用组合替代集成</li>
<li>单一职责原则（SRP–Single Responsibility Principle）</li>
</ol>
<p>1-3用于降低隐式耦合，4-6用于降低访问耦合，7-9用于降低继承耦合</p>
<p><strong>题目</strong>：给出例子，找出其违法的原则，并修正</p>
<h3 id="访问耦合"><a href="#访问耦合" class="headerlink" title="访问耦合"></a>访问耦合</h3><p>类A拥有对类B的引用，则A可以访问B，存在耦合</p>
<p>分类（高到低）：</p>
<ul>
<li>隐式访问：B既没有在A的规格中出现，也没有在实现中出现（连续的方法调用，方法套娃）</li>
<li>实现中访问：B的引用是A方法中的局部变量</li>
<li>成员变量访问：B的引用是A的方法对参数变量</li>
<li>参数变量访问：B的引用是A的方法对参数变量</li>
<li>无访问：理论最优，无关联耦合，维护时不需要对方任何信息</li>
</ul>
<p>降低访问耦合的方法：</p>
<ul>
<li>针对接口编程</li>
<li>接口最小化/接口分离原则</li>
<li>访问耦合的合理范围/迪米特法则</li>
</ul>
<h3 id="继承耦合"><a href="#继承耦合" class="headerlink" title="继承耦合"></a>继承耦合</h3><p>继承里，父类和子类之间存在耦合</p>
<p>类型（从高到低）：</p>
<ul>
<li>修改<ul>
<li>规格：子类修改继承回来的方法的接口</li>
<li>实现：子类修改继承回来的方法的实现</li>
</ul>
</li>
<li>精化<ul>
<li>规格：子类根据定义好的规则来修改父类的方法，且至少有一个方法的接口被改动</li>
<li>实现：子类根据定义好的规则来修改父类的方法，但是只改动了方法的实现</li>
</ul>
</li>
<li>扩展：子类只增加新的方法和成员变量，不对从父类继承回来的成员做任何修改</li>
<li>无：两个类之间没有继承关系</li>
</ul>
<p>降低继承耦合的方法：</p>
<ul>
<li>里氏替换原则</li>
<li>使用组合代替继承</li>
</ul>
<h3 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h3><p>分类：</p>
<ul>
<li>方法内聚：和结构化中的函数内聚一致，体现方法实现时语句之间的内聚性</li>
<li>类的内聚：衡量类的成员变量和方法之间的内聚</li>
<li>继承内聚：继承树中类之间的内聚</li>
</ul>
<p>提高内聚的方法：</p>
<ul>
<li>集中信息与行为</li>
<li>单一职责行为</li>
</ul>
<h2 id="第15章-详细设计中面向对象方法下的信息隐藏"><a href="#第15章-详细设计中面向对象方法下的信息隐藏" class="headerlink" title="第15章 详细设计中面向对象方法下的信息隐藏"></a>第15章 详细设计中面向对象方法下的信息隐藏</h2><h3 id="信息隐藏的含义"><a href="#信息隐藏的含义" class="headerlink" title="信息隐藏的含义"></a>信息隐藏的含义</h3><ul>
<li>封装类的职责，隐藏职责的实现</li>
<li>预计将会发生的变更，抽象它的接口，隐藏内部实现机制</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="*封装"></a>*封装</h3><p>分离接口和实现</p>
<p>含义：</p>
<ul>
<li>将数据和行为同时包含在类中</li>
<li>分离对外接口和内部实现</li>
</ul>
<p>实现细节：</p>
<ul>
<li>封装数据与行为</li>
<li>封装内部结构</li>
<li>封装其他对象的引用</li>
<li>封装类型信息</li>
<li>封装潜在变更</li>
</ul>
<h3 id="开放关闭原则（OCP–Open-Close-Principle）"><a href="#开放关闭原则（OCP–Open-Close-Principle）" class="headerlink" title="*开放关闭原则（OCP–Open Close Principle）"></a>*开放关闭原则（OCP–Open Close Principle）</h3><p>是面向对象设计的一个指导性、方针性原则</p>
<p>具体内容：</p>
<ul>
<li>好的设计应该对“扩展”开发</li>
<li>好的设计应该对“修改”关闭</li>
</ul>
<p>简单来讲，发生变更时，好的设计只需要添加新的代码而不需要修改原有的代码</p>
<h3 id="依赖倒置原则（DIP–Dependence-Inversion-Principle）"><a href="#依赖倒置原则（DIP–Dependence-Inversion-Principle）" class="headerlink" title="*依赖倒置原则（DIP–Dependence Inversion Principle）"></a>*依赖倒置原则（DIP–Dependence Inversion Principle）</h3><p>内容：</p>
<ul>
<li>抽象不应该依赖于细节，细节应该依赖于抽象。因为抽象是稳定的，细节不稳定</li>
<li>高层模块不应该依赖于底层模块，双方都依赖于抽象。因为抽象是稳定的，而高层模块和底层模块都可能是不稳定的。</li>
</ul>
<p><strong>题目</strong>：根据类图，运用或违反了哪条面向对象设计原则？</p>
<h2 id="第16章-详细设计的设计模式"><a href="#第16章-详细设计的设计模式" class="headerlink" title="第16章 详细设计的设计模式"></a>第16章 详细设计的设计模式</h2><h3 id="如何实现可修改性、可扩展性、灵活性"><a href="#如何实现可修改性、可扩展性、灵活性" class="headerlink" title="如何实现可修改性、可扩展性、灵活性"></a>如何实现可修改性、可扩展性、灵活性</h3><p>实现接口和实现分离</p>
<ul>
<li>通过接口和实现该接口的类完成分离</li>
<li>通过子类继承父类，将父类的接口与子类的实现分离</li>
</ul>
<p>四种模式必考一种，给定场景，应用设计模式并写伪码；给出代码，要求用设计模式改写</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>减少耦合、依赖倒置</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>职责抽象、接口和重用</p>
<h3 id="单例模式（单件模式）"><a href="#单例模式（单件模式）" class="headerlink" title="单例模式（单件模式）"></a>单例模式（单件模式）</h3><p>职责抽象</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>减少耦合、依赖倒置</p>
<h2 id="第17章-软件构造"><a href="#第17章-软件构造" class="headerlink" title="第17章 软件构造"></a>第17章 软件构造</h2><h3 id="构造包含的活动"><a href="#构造包含的活动" class="headerlink" title="构造包含的活动"></a>构造包含的活动</h3><p>详细设计、编程、测试、调试、代码评审、集成与构建、构造与管理</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="*名词解释"></a>*名词解释</h3><p>重构、测试驱动开发、结对编程</p>
<h2 id="第18章-代码设计"><a href="#第18章-代码设计" class="headerlink" title="第18章 代码设计"></a>第18章 代码设计</h2><h3 id="给定代码段示例，对其进行改进或者发现其中问题"><a href="#给定代码段示例，对其进行改进或者发现其中问题" class="headerlink" title="*给定代码段示例，对其进行改进或者发现其中问题"></a>*给定代码段示例，对其进行改进或者发现其中问题</h3><ul>
<li>简洁性/可维护性</li>
<li>使用数据结构消减复杂判定</li>
<li>控制结构</li>
<li>变量的使用</li>
<li>语句处理</li>
<li>如何写不可维护的代码</li>
<li>防御和错误处理</li>
</ul>
<h3 id="单元测试用例的设计"><a href="#单元测试用例的设计" class="headerlink" title="*单元测试用例的设计"></a>*单元测试用例的设计</h3><ul>
<li>基于规格的测试技术开发测试用例，等价类划分和边界值分析</li>
<li>基于代码的测试技术开发测试用例，关键复杂代码：路径覆盖；复杂代码；分支覆盖；简单代码；语句覆盖</li>
</ul>
<h3 id="表驱动编程"><a href="#表驱动编程" class="headerlink" title="*表驱动编程"></a>*表驱动编程</h3><p>if-else  –&gt; 一张表</p>
<h3 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h3><p>断言式设计</p>
<p>基本思想：如果一个函数和方法，在前置条件满足的情况下开始执行，玩抽能够满足后置条件，那么这个函数或方法就是正确的、可靠的</p>
<p>常见方式：异常和断言（Assert）</p>
<p>检查很多外来信息的有效性：</p>
<ul>
<li>输入参数，是否合法</li>
<li>用户输入，是否有效</li>
<li>外部文件，是否存在</li>
</ul>
<h3 id="防御式编程"><a href="#防御式编程" class="headerlink" title="*防御式编程"></a>*防御式编程</h3><p>基本思想：在一个地方与其他方法、操作系统、硬件等外界环境交互时，不能确保外界都是正确的，所以要在外界发生错误时，保护内部方法不受损害</p>
<h2 id="第19章-软件测试"><a href="#第19章-软件测试" class="headerlink" title="第19章 软件测试"></a>第19章 软件测试</h2><p>单元测试、集成测试、系统测试</p>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>基于规格的技术，把测试对象看作一个黑盒子，完全基于输入和输出来判定测试对象的正确性。测试使用测试对象的规格说明来设计输入和输出数据</p>
<p>常见方法：</p>
<ul>
<li>等价类划分（把输入按照等价类划分、包括有效和无效）</li>
<li>边界值分析</li>
<li>决策表（表驱动）</li>
<li>状态转换</li>
</ul>
<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>基于代码的技术，把测试对象看成透明的，不关心测试对象的规格，而是按照测试对象内部的程序结构来设计测试用例进行测试工作</p>
<p>方法：</p>
<ul>
<li>语句覆盖：确保被测试对象的每一行程序代码都至少执行一次</li>
<li>条件覆盖：确保程序中每个判断的每个结果都至少满足一次</li>
<li>路径覆盖：确保程序中每条独立的执行路径都至少执行一次</li>
</ul>
<p><strong>题目</strong>：</p>
<p>白盒测试和黑盒测试的常见方法，并比较优缺点</p>
<p>能解释并区别白盒测试的三种不同的方法</p>
<p>给出一个场景，判断应该使用哪种测试方法，如何去写</p>
<ul>
<li><p>给出功能需求–写功能测试用例</p>
</li>
<li><p>给出设计图–写集成测试用例，Stub和Driver</p>
</li>
<li><p>给出方法描述–写单元测试用例，Mock Project</p>
</li>
<li><p>JUnit的使用</p>
</li>
</ul>
<h2 id="第20章-软件交付"><a href="#第20章-软件交付" class="headerlink" title="第20章 软件交付"></a>第20章 软件交付</h2><p><strong>用户文档、系统稳定</strong></p>
<h2 id="第21章-软件维护与演化"><a href="#第21章-软件维护与演化" class="headerlink" title="第21章 软件维护与演化"></a>第21章 软件维护与演化</h2><h3 id="如何理解软件维护的重要性"><a href="#如何理解软件维护的重要性" class="headerlink" title="如何理解软件维护的重要性"></a>如何理解软件维护的重要性</h3><p>修改代价高</p>
<h3 id="开发可维护软件的方法"><a href="#开发可维护软件的方法" class="headerlink" title="开发可维护软件的方法"></a>开发可维护软件的方法</h3><ul>
<li>考虑软件的可变更性<ul>
<li>分析需求的易变性</li>
<li>为变更进行设计</li>
</ul>
</li>
<li>为降低维护困难而开发<ul>
<li>编写详细的技术文档并保持及时更新</li>
<li>保证代码的可读性</li>
<li>维护需求跟踪链</li>
<li>维护回归测试基线</li>
</ul>
</li>
</ul>
<h3 id="软件演化生命周期模型"><a href="#软件演化生命周期模型" class="headerlink" title="*软件演化生命周期模型"></a>*软件演化生命周期模型</h3><p>初步开放、演化、服务、逐步淘汰、停止</p>
<h3 id="逆向工程、再工程"><a href="#逆向工程、再工程" class="headerlink" title="逆向工程、再工程"></a>逆向工程、再工程</h3><h2 id="第22章-软件开发过程的模型"><a href="#第22章-软件开发过程的模型" class="headerlink" title="第22章 软件开发过程的模型"></a>第22章 软件开发过程的模型</h2><h3 id="软件演化生命周期模型-1"><a href="#软件演化生命周期模型-1" class="headerlink" title="*软件演化生命周期模型"></a>*软件演化生命周期模型</h3><p>软件生命周期模型（Life Cycle Model）是描述软件开发过程中各种活动如何执行的模型。各种模型确立了软件开发中各阶段的次序限制以及开发过程所遵守的规定和限制</p>
<ol>
<li>需求工程</li>
<li>软件设计</li>
<li>软件实现</li>
<li>软件测试</li>
<li>软件交付</li>
<li>软件维护</li>
</ol>
<h3 id="解释与比较过程模型（要求、特征描述、优点、缺点）"><a href="#解释与比较过程模型（要求、特征描述、优点、缺点）" class="headerlink" title="*解释与比较过程模型（要求、特征描述、优点、缺点）"></a>*解释与比较过程模型（要求、特征描述、优点、缺点）</h3><p><strong>构建-修复模型</strong>：</p>
<p>最早最自然产生的软件开发模型。没有规划组织，完全依靠开发人员的个人能力</p>
<p>缺点：</p>
<ul>
<li>没有分工，随着软件系统复杂度上升，开发活动超出个人控制能力</li>
<li>没有分析需求的真实性，给软件开发带来很大的风险</li>
<li>软件结构的质量随着修改越来越差</li>
<li>没有考虑可维护性</li>
</ul>
<p>使用范围：</p>
<ul>
<li>软件规模很小，只有几百行程序</li>
<li>对软件质量要求不高，即使出错也无所谓</li>
<li>只关注开发，对后期维护要求不高</li>
</ul>
<p><strong>瀑布模型</strong></p>
<p>按照软件生命周期模型将软件开发活动组织为需求开发、软件设计、软件实现、软件测试、软件交付和软件维护等基本活动，并且规定了它们自上而下、相互邻接的次序。允许反复和迭代，重点在于每个活动必须进行验证，文档驱动。</p>
<p>优点：对于软件开放活动有明确的阶段划分，有利于开发者以关注点分离的方式更好地进行复杂软件项目的开放</p>
<p>缺点：</p>
<ul>
<li>对文档期望过高</li>
<li>对开放活动的线性顺序假设具有局限性</li>
<li>客户、用户参与度具有局限性</li>
<li>里程碑粒度过粗（软件复杂使得每个阶段时间长，无法尽早发现缺陷）</li>
</ul>
<p>适用性：</p>
<ul>
<li>需求非常成熟、稳定，没有不确定的内容，也不会发生变化</li>
<li>所需的技术成熟，可靠，没有不确定的技术难点，也没有开发人员不熟悉的技术问题</li>
<li>复杂度适中，不至于产生太太的文档负担和过粗的里程碑</li>
</ul>
<p>Note：周期过长和渐进演化。时间压力和并行开发</p>
<p><strong>螺旋模型</strong></p>
<p>螺旋模型将软件开发活动组织为风险解决的迭代（风险驱动）</p>
<p>风险：指因为不确定性（对未来知识里了解有限）而可能给项目带来损失的情况</p>
<p>基本思想：尽早解决比较高的风险，如果有些问题实在无法解决，那么早发现比项目结束时再发现要更好，至少损失会小很多</p>
<p>优先：降低风险，减少因风险造成的损失</p>
<p>缺点：</p>
<ul>
<li>使用原型方法，为自身带来风险</li>
<li>模型过于负责，不利于管理者依据其组织软件开发活动</li>
</ul>
<p>适用性：高风险的大规模软件系统开发</p>
<p><strong>原型模型、演化模型、增量迭代模型</strong>详见<strong>软工二复习—TJY</strong></p>
<h3 id="Rational统一过程（RUP）"><a href="#Rational统一过程（RUP）" class="headerlink" title="Rational统一过程（RUP）"></a>Rational统一过程（RUP）</h3><h3 id="敏捷过程"><a href="#敏捷过程" class="headerlink" title="敏捷过程"></a>敏捷过程</h3><h3 id="软件工程知识体系知识域"><a href="#软件工程知识体系知识域" class="headerlink" title="软件工程知识体系知识域"></a>软件工程知识体系知识域</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/03/%E8%BD%AF%E5%B7%A5%E4%BA%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" data-id="ckemevyyd000x74u85qy02lzt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E5%B7%A5%E4%BA%8C/" rel="tag">软工二</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/09/03/%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          软工二需求文档
        
      </div>
    </a>
  
  
    <a href="/2020/09/03/%E8%AF%A6%E7%BB%86%E7%94%A8%E4%BE%8B%E6%8F%8F%E8%BF%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">软工二用例文档</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VUE/" rel="tag">VUE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/" rel="tag">数据科学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/" rel="tag">数据科学基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%BD%91/" rel="tag">计网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E5%B7%A5%E4%BA%8C/" rel="tag">软工二</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/VUE/" style="font-size: 10px;">VUE</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/" style="font-size: 10px;">数据科学</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">数据科学基础</a> <a href="/tags/%E8%AE%A1%E7%BD%91/" style="font-size: 20px;">计网</a> <a href="/tags/%E8%BD%AF%E5%B7%A5%E4%BA%8C/" style="font-size: 20px;">软工二</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/03/%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3/">软工二需求文档</a>
          </li>
        
          <li>
            <a href="/2020/09/03/%E8%BD%AF%E5%B7%A5%E4%BA%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">软工二知识点整理</a>
          </li>
        
          <li>
            <a href="/2020/09/03/%E8%AF%A6%E7%BB%86%E7%94%A8%E4%BE%8B%E6%8F%8F%E8%BF%B0/">软工二用例文档</a>
          </li>
        
          <li>
            <a href="/2020/09/03/%E8%AE%A1%E7%BD%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BF%AD%E4%BB%A3%E4%BA%8C%E5%BC%80%E5%8F%91/">计网小程序迭代</a>
          </li>
        
          <li>
            <a href="/2020/09/03/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%A4%A7%E4%BD%9C%E4%B8%9A%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/">数据科学基础大作业</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>